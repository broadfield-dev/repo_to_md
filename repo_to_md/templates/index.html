<!-- repo_to_md_test/repo_to_md/templates/index.html (Corrected and Complete) -->
<!DOCTYPE html>
<html>
<head>
    <title>Repo & Files to Markdown</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <!-- Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/okaidia.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

    <style>
        /* Reset some default styles */
        body, h1, h2, h3, p, ul, li {
            margin: 0;
            padding: 0;
        }

        .file-container {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
        }

        .file-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .code-block {
            background-color: #272822;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            max-height: 300px;
            margin-bottom: 10px; /* Spacing below code */
        }

        .preview-iframe {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
        }

        .download-button {
            padding: 5px 10px;
            background-color: #4CAF50; /* Green */
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: smaller;
        }

        /* --- Tabs --- */
        .tab {
            overflow: hidden;
            background-color: #282c34; /* Dark background for tabs */
            border-bottom: 1px solid #ccc;
            margin-bottom: 20px; /* Spacing below tabs */
        }

        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 10px 15px;
            transition: 0.3s;
            color: #fff; /* White text */
        }

        .tab button:hover {
            background-color: #44475a; /* Lighter background on hover */
        }

        .tab button.active {
            background-color: #61af69; /* Active tab color */
            color: black;
        }

        .tabcontent {
            display: none;
            padding: 10px; /* Reduced padding inside tab content */
            border: 1px solid #ccc;
            border-top: none;
        }

        /* --- Mode Toggle --- */
        .mode-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
        }
        .hidden {
            display: none;
        }

        /* --- General --- */
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            transition: background 0.3s, color 0.3s;
        }

       body.dark-mode {
            background: linear-gradient(to bottom right, #1A252F, #2C3E50);
            color: #E0E6ED;
        }

        /* White is Transparent */
        body.dark-mode .input-section,
        body.dark-mode .markdown-section,
        body.dark-mode .preview-section {
            background: transparent;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        .spinner {
            display: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .output-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .markdown-section, .preview-section {
            flex: 1;
            min-width: 300px;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1.02); }
        }

        .copy-button {
            padding: 8px 16px;
            background: #3498DB;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
            transition: background 0.3s, transform 0.1s;
        }

        .copy-button:hover {
            background: #2C7DB2;
        }

        .copy-button:active {
            transform: scale(0.97) translateY(2px);
        }
        #filesDisplay {
             margin-top: 20px;
        }


    </style>
</head>
<body class="dark-mode">
    <div class="container">
        <div class="mode-toggle">
            <label class="switch">
                <input type="checkbox" id="modeToggle" onchange="toggleMode()">
                <span class="slider"></span>
            </label>
            <label for="modeToggle">Light Mode</label>
        </div>

        <div class="tab">
            <button class="tablinks active" onclick="openTab(event, 'repoToMarkdown')">Repo to Markdown</button>
            <button class="tablinks" onclick="openTab(event, 'markdownToFiles')">Markdown to Files</button>
        </div>

        <!-- Repo to Markdown Tab -->
        <div id="repoToMarkdown" class="tabcontent" style="display: block;">
            <div class="input-section">
                <h1>Repository & Files to Markdown Converter</h1>
                <p>Enter a GitHub/Hugging Face Space URL</p>
                <input type="text" id="repoUrl" placeholder="Enter GitHub or Hugging Face Space URL">
                <p>OR upload files</p>
                <input type="file" id="fileInput" multiple webkitdirectory>
                <br>
                <button onclick="processRepo()">Convert URL</button>
                <button onclick="processFiles()">Convert Files</button>
                <button id="downloadBtn" style="display: none;" onclick="downloadMarkdown()">Download .md</button>
                <div id="spinner" class="spinner"></div>
            </div>
            <div class="output-container">
                <div class="markdown-section">
                    <h2>Markdown Output: <button class="copy-button" onclick="copyToClipboard()">Copy</button></h2>
                    <textarea id="markdownOutput" readonly></textarea>
                </div>
                <div class="preview-section">
                    <h2>Preview:</h2>
                    <div id="output"></div>
                </div>
            </div>
        </div>

        <!-- Markdown to Files Tab -->
        <div id="markdownToFiles" class="tabcontent">
            <div class="input-section">
                <h2>Markdown to Files</h2>
                <p>Upload a Markdown file:</p>
                <input type="file" id="markdownFileInput">
                <p>Or paste Markdown text:</p>
                <textarea id="markdownPasteInput" placeholder="Paste Markdown here"></textarea>
                <button onclick="reverseProcess()">Extract Files</button>
                <div id="reverseSpinner" class="spinner" style="display: none;"></div>
            </div>

            <div id="filesDisplay">
               <!-- File containers go here -->
            </div>
            <button id="downloadExtractedBtn" class="hidden" onclick="downloadExtractedFiles()">Download All Files (zip)</button>

           <div id="combinedPreview" style="margin-bottom: 20px;">
                <h3>Combined HTML Preview:</h3>
                <div id="combinedPreviewContent"></div> <!-- Container for iframes -->
            </div>
        </div>
    </div>

    <script>
        let currentMarkdown = '';
        let currentFilename = '';
        let extractedFiles = [];
    
        // Tab switching
        function openTab(evt, tabName) {
            let i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tabcontent");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tablinks");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }
    
        // Light/Dark Mode Toggle
        function toggleMode() {
            const body = document.body;
            const toggle = document.getElementById('modeToggle');
            body.classList.toggle('dark-mode', !toggle.checked);
            body.classList.toggle('light-mode', toggle.checked);
        }
    
        // --- Repo to Markdown Functions ---
        async function processRepo() {
            const repoUrl = document.getElementById('repoUrl').value;
            await processContent('/process', { repo_url: repoUrl });
        }
    
        async function processFiles() {
            const files = document.getElementById('fileInput').files;
            if (files.length === 0) {
                alert('Please select at least one file or folder');
                return;
            }
            const formData = new FormData();
            for (let file of files) {
                formData.append('files[]', file);
            }
            await processContent('/process', formData, false);
        }
    
        async function processContent(url, data, isJson = true) {
            const spinner = document.getElementById('spinner');
            const buttons = document.querySelectorAll('button');
            spinner.style.display = 'block';
            buttons.forEach(btn => btn.disabled = true);
    
            try {
                const options = {
                    method: 'POST',
                    ...(isJson ? {
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    } : { body: data })
                };
                const response = await fetch(url, options);
                const result = await response.json();
    
                if (result.error) {
                    alert(result.error);
                    return;
                }
    
                currentMarkdown = result.markdown;
                currentFilename = result.filename;
                document.getElementById('markdownOutput').value = result.markdown;
                document.getElementById('output').innerHTML = result.html;
                document.getElementById('downloadBtn').style.display = 'inline-block';
    
                const markdownOutput = document.getElementById('markdownOutput');
                const output = document.getElementById('output');
                markdownOutput.classList.add('fade-in');
                output.classList.add('fade-in');
                setTimeout(() => {
                    markdownOutput.classList.remove('fade-in');
                    output.classList.remove('fade-in');
                }, 500);
    
                const markdownHeight = markdownOutput.scrollHeight;
                const outputHeight = output.scrollHeight;
                const maxHeight = Math.max(markdownHeight, outputHeight);
                markdownOutput.style.height = `${maxHeight}px`;
                output.style.maxHeight = `${maxHeight}px`;
            } catch (error) {
                alert('An error occurred: ' + error.message);
            } finally {
                spinner.style.display = 'none';
                buttons.forEach(btn => btn.disabled = false);
            }
        }
    
        async function downloadMarkdown() {
            try {
                const response = await fetch('/download', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        markdown: currentMarkdown,
                        filename: currentFilename
                    })
                });
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = currentFilename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                window.URL.revokeObjectURL(url);
            } catch (error) {
                alert('Error downloading file: ' + error.message);
            }
        }
    
        async function copyToClipboard() {
            const markdownOutput = document.getElementById('markdownOutput');
            if (!markdownOutput || !markdownOutput.value) {
                alert('Nothing to copy!');
                return;
            }
            try {
                await navigator.clipboard.writeText(markdownOutput.value);
                alert('Markdown copied to clipboard!');
            } catch (err) {
                console.error('Clipboard API failed:', err);
                markdownOutput.select();
                try {
                    document.execCommand('copy');
                    alert('Markdown copied to clipboard (legacy method)!');
                } catch (fallbackErr) {
                    alert('Failed to copy to clipboard: ' + (err.message || 'Unknown error'));
                }
            }
        }
    
        // --- Markdown to Files Functions ---
        async function reverseProcess() {
            let markdownText = '';
            const markdownFile = document.getElementById('markdownFileInput').files[0];
            const markdownPasteInput = document.getElementById('markdownPasteInput').value;

            if (markdownFile) {
                markdownText = await markdownFile.text();
            } else if (markdownPasteInput) {
                markdownText = markdownPasteInput;
            } else {
                alert('Please upload a Markdown file or paste Markdown text.');
                return;
            }

            const formData = new FormData();
            formData.append('markdown_file', new Blob([markdownText], { type: 'text/markdown' }));

            const reverseSpinner = document.getElementById('reverseSpinner');
            const buttons = document.querySelectorAll('button');
            reverseSpinner.style.display = 'block';
            buttons.forEach(btn => btn.disabled = true);

            try {
                const response = await fetch('/reverse', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    alert(errorData.error || 'An error occurred.');
                    return;
                }

                const result = await response.json();
                if (result.error) {
                    alert(result.error);
                    return;
                }

                console.log('Reverse result:', result);
                extractedFiles = result.files;
                displayExtractedFiles(result.files);
                document.getElementById('combinedPreviewContent').innerHTML = result.combined_html;
                document.getElementById('downloadExtractedBtn').classList.remove('hidden');
            } catch (error) {
                console.error('Reverse process error:', error);
                alert('An error occurred: ' + error.message);
            } finally {
                reverseSpinner.style.display = 'none';
                buttons.forEach(btn => btn.disabled = false);
            }
        }

    
        function displayExtractedFiles(files) {
            const filesDisplay = document.getElementById('filesDisplay');
            if (!filesDisplay) {
                console.error('filesDisplay element not found');
                return;
            }
            filesDisplay.innerHTML = ''; // Clear previous content
    
            if (!files || files.length === 0) {
                filesDisplay.innerHTML = '<p>No files extracted.</p>';
                console.warn('No files to display:', files);
                return;
            }
    
            for (const file of files) {
                console.log('Displaying file:', file);  // Debug each file
                const fileContainer = document.createElement('div');
                fileContainer.className = 'file-container';
    
                const fileNameDiv = document.createElement('div');
                fileNameDiv.className = 'file-name';
                fileNameDiv.textContent = file.filename;
                fileContainer.appendChild(fileNameDiv);
    
                if (!file.is_binary) {
                    const codeBlock = document.createElement('pre');
                    codeBlock.className = 'code-block hljs';
                    const code = document.createElement('code');
                    const fileExtension = file.filename.split('.').pop().toLowerCase();
                    code.className = `language-${fileExtension}`;
                    code.textContent = file.content;
                    codeBlock.appendChild(code);
                    fileContainer.appendChild(codeBlock);
                    hljs.highlightElement(code);
                } else {
                    const binaryNotice = document.createElement('p');
                    binaryNotice.textContent = 'This is a binary file.';
                    fileContainer.appendChild(binaryNotice);
                }
    
                const previewDownloadContainer = document.createElement('div');
                const downloadButton = document.createElement('button');
                downloadButton.className = 'download-button';
                downloadButton.textContent = 'Download';
                downloadButton.onclick = () => downloadSingleFile(file.filepath, file.filename);
                previewDownloadContainer.appendChild(downloadButton);
                fileContainer.appendChild(previewDownloadContainer);
    
                if (file.filename.endsWith(".html") && !file.is_binary) {
                    const previewIframe = document.createElement("iframe");
                    previewIframe.className = "preview-iframe";
                    previewIframe.src = `/temp/${file.filepath}`;
                    fileContainer.appendChild(previewIframe);
                }
    
                filesDisplay.appendChild(fileContainer);
            }
        }
    
        async function downloadSingleFile(filepath, filename) {
            try {
                const response = await fetch('/download_file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filepath: filepath })
                });
    
                if (!response.ok) {
                    const errorData = await response.json();
                    alert(errorData.error || 'An error occurred during download.');
                    return;
                }
    
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                window.URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Download error:', error);
                alert('Error downloading file: ' + error.message);
            }
        }
    
        async function downloadExtractedFiles() {
            try {
                const response = await fetch('/download_extracted', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ files: extractedFiles })
                });
    
                if (!response.ok) {
                    const errorData = await response.json();
                    alert(errorData.error || 'An error occurred during download.');
                    return;
                }
    
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "extracted_files.zip";
                document.body.appendChild(a);
                a.click();
                a.remove();
                window.URL.revokeObjectURL(url);
            } catch (error) {
                alert('Error downloading files: ' + error.message);
            }
        }
    
        // Initialize Highlight.js
        document.addEventListener('DOMContentLoaded', (event) => {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
